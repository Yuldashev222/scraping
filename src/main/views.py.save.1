import re
from datetime import datetime
from elasticsearch_dsl import Q
from collections import OrderedDict
from rest_framework.response import Response
from rest_framework.generics import ListAPIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.pagination import PageNumberPagination

from .models import FileDetail
from .documents import FileDetailDocument
from .enums import InformCountry, InformRegion
from .tasks import create_search_detail_obj
from .serializers import FileDetailDocumentSerializer


class CustomPageNumberPagination(PageNumberPagination):
    def get_paginated_response(self, data):
        count = self.page.paginator.count
        search_text = self.request.query_params.get('search', '').strip()
        if bool(search_text):
            create_search_detail_obj.delay(
                search_text=search_text,
                files_cnt=count,
                forwarded=self.request.META.get('HTTP_X_FORWARDED_FOR'),
                real=self.request.META.get('HTTP_X_REAL_IP'),
                remote=self.request.META.get('REMOTE_ADDR')
            )
        return Response(OrderedDict([
            ('count', count),
            ('next', self.get_next_link()),
            ('previous', self.get_previous_link()),
            ('results', data)
        ]))


class SearchFilesView(ListAPIView):
    serializer_class = FileDetailDocumentSerializer
    pagination_class = CustomPageNumberPagination
    document_class = FileDetailDocument
    queryset = FileDetail.objects.all()
    permission_classes = [IsAuthenticated]

    @staticmethod
    def all_q_expression(query):
        a = query
        b = query.split()
        b.reverse()
        r_query = ' '.join(b)
        print(a)
        print(r_query)
        print('====================')
        return Q(
            'bool',
            should=[
                Q('match_phrase', text={'query': a, 'slop': 6}),
                Q('match_phrase', text={'query': r_query, 'slop': 6})
            ]
        )

    @staticmethod
    def ignore_q_expression(query):
        return Q('bool', must_not=[Q('regexp', text=f'.*{query}.*')])

    @staticmethod
    def exact_q_expression(query):
        return Q(
            'bool',
            should=[Q('match_phrase', text=query)],
            minimum_should_match=1
        )

    @staticmethod
    def filter_q_expression(dct):
        return Q('term', **dct)

    @staticmethod
    def date_q_expression(year):
        start_date = datetime(year=year, month=1, day=1)
        end_date = datetime(year=year, month=12, day=31)
        return Q(
            'range',
            file_date={'gte': start_date, 'lte': end_date}
        )

    def get(self, request, *args, **kwargs):
        search_query = str(request.query_params.get('search', '')).strip()
        ordering_query = str(request.query_params.get('ordering', '')).strip()
        filter_date_query = str(request.query_params.get('file_date', '')).strip()

        search = self.document_class.search().sort({'_id': {'order': 'desc'}})
        if bool(filter_date_query) and len(filter_date_query) == 4 and filter_date_query.isdigit():
            year = int(filter_date_query)
            try:
                search = search.query(self.date_q_expression(year))
            except:
                pass

        filter_organ_query = str(request.query_params.get('organ', '')).strip()
        if bool(filter_organ_query) and len(filter_organ_query) == 1 and filter_organ_query in 'sf':
            search = search.query(self.filter_q_expression({'organ': filter_organ_query}))

        filter_country_query = str(request.query_params.get('country', '')).strip()
        if bool(filter_country_query) and filter_country_query in InformCountry.keys():
            search = search.query(self.filter_q_expression({'country': filter_country_query}))

        filter_region_query = str(request.query_params.get('region', '')).strip()
        if bool(filter_region_query) and filter_region_query in InformRegion.keys():
            search = search.query(self.filter_q_expression({'region': filter_region_query}))

        if bool(search_query):
            search_query = ' '.join(search_query.split()).lower()
            search_query_copy = search_query

            required_pattern = r'".{,}"'
            required_text = re.search(required_pattern, search_query)
            if bool(required_text):
                required_text = required_text.group()
                search_query = search_query.replace(required_text, '').strip()
                required_text = required_text[1:required_text.index('"', 1)]
                q = self.exact_q_expression(required_text)
                search = search.query(q).sort({"_score": {"order": "desc"}})
            ignore_texts = list(filter(lambda el: el[0] == '-', str(' ' + search_query + ' ').split()))
	    if bool(ignore_texts):
                for i in ignore_texts:
                    q_text = self.ignore_q_expression(i.replace('-', ''))
                    search_query = search_query.replace(i, '')
                    search = search.query(q_text)

            if not bool(required_text) and bool(search_query.strip()):
                q = self.all_q_expression(search_query.strip())
                search = search.query(q).sort({"_score": {"order": "desc"}})

        if bool(ordering_query) and ordering_query in ['-file_date', 'file_date']:
            if ordering_query.startswith('-'):
                search = search.sort('-file_date')
            else:
                search = search.sort('file_date')

        page = self.paginate_queryset(search)
        serializer = self.serializer_class(page, many=True, context={'request': request})
        return self.get_paginated_response(serializer.data)

